<!DOCTYPE html>
<html>
<head>
  <!-- ... -->
  <link rel="stylesheet" href="css/bootstrap.min.css">
  <link rel="stylesheet" href="css/bootstrap-theme.min.css">
  <style>
    html
    {
        font-family: 'Calibri';
    }
    body
    {
        margin: 1em;
    }
    label
    {
        font-weight: bold;
        text-transform: uppercase;
        font-family: 'Calibri';
    }

    .group {
        margin-right: 0;
        margin-left: 0;
        background-color: #fff;
        border: 1px solid gray;
        padding: 1em;
        -webkit-box-shadow: none;
                box-shadow: none;
    }

    .panel
    {
        overflow: hidden;
    }
  </style>
  <script src="js/konva.min.js"></script>
  <script src="js/zepto.min.js"></script>
  <script src="js/anime.min.js"></script>
  <script src="js/tinycolor.min.js"></script>
  <script src="js/jquery.serialize-object.min.js"></script>
  <title>Генератор отстроечных таблиц</title>
  <!-- ... -->
</head>
<body>
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <form class="form-group" id="genform">
                    <div class="col-md-4">
                    <button class="btn btn-success btn-block" id="addRect">ДОБАВИТЬ ЭКРАН</button>
                    <br/>
                    <input class="btn btn-primary btn-block" id="generate" type="submit" value="СГЕНЕРИРОВАТЬ" />
                    </div>
                    <div class="col-md-8">
                    <div class="form-group panel panel-default">
                        <div class="panel-heading">Экран №1</div>
                        <div class="panel-body">
                            <label for="text">Текст</label>
                            <input class="form-control" name="rect[0][text]" id="text" value="Экран"/>
                            <label for="width">Ширина</label>
                            <input class="form-control" name="rect[0][width]" type="number" id="width" value="1024"/>
                            <label for="height">Высота</label>
                            <input class="form-control" name="rect[0][height]" type="number" id="height" value="768"/>
                            <label for="color">Цвет</label>
                            <input class="form-control" name="rect[0][color]" type="color" id="color" value="#0000FF" style="height: 50px"/>
                        </div>
                    </div>
                    <div id="preRect"/>
                    </div>
                </form>
                <div id="canvas" style="display: none" />
            </div>
        </div>
    </div>
    
  <!-- ... -->
</body>
<script>
    var rectCount = 1;
    var colors = ["Blue","Red","Lime","Magenta","Yellow","White","Black"];
    function GeneratePixelMap(width, height, data)
    {
        var stage = new Konva.Stage({
        container: 'canvas',
        width: width,
        height: height
        });

        var layer = new Konva.Layer();
        layer.add(new Konva.Rect({
            width: width,
            height: height,
            fill: 'black'
        }));
        //var color = tinycolor('blue');
        var x = 0;
        data.forEach(function(element) {
            layer.add(DrawRectangle(tinycolor(element.color), x, element));
            x += element.width * 1;
        }, this);
        
        layer.add(DrawGrid(stage, 32));
        layer.add(DrawCheckerboard(stage, 32));
        layer.add(DrawNumbers(stage, 32));

        x = 0;
        data.forEach(function(element) {    
            layer.add(DrawOverlay(tinycolor(element.color), x, element));
            x += element.width * 1;
        }, this);

        stage.add(layer);
        return stage;
    }
    function InvertColor(color)
    {
        var rgb = color.toRgb();
        return tinycolor({r: 255 - rgb.r, g: 255 - rgb.g, b: 255 - rgb.b});
    }
    function DrawRectangle(color, position, data)
    {
        const size = 32;
        const d = 16;
        
        var inverted = InvertColor(color);

        var layer = new Konva.Group();

        layer.add(new Konva.Rect({
            x: position,
            width: data.width,
            height: data.height,
            fill: color.toHexString(),
            stroke: inverted.toHexString(),
            strokeWidth: 8
        }));

        layer.add(new Konva.Rect({
            x: position + d,
            y: d,
            width: size,
            height: size,
            fill: inverted.toHexString()
        }));

        layer.add(new Konva.Rect({
            x: position + data.width - d - size,
            y: d,
            width: size,
            height: size,
            fill: inverted.toHexString()
        }));

        layer.add(new Konva.Rect({
            x: position + data.width - d - size,
            y: data.height - d - size,
            width: size,
            height: size,
            fill: inverted.toHexString()
        }));

        layer.add(new Konva.Rect({
            x: position + d,
            y: data.height - d - size,
            width: size,
            height: size,
            fill: inverted.toHexString()
        }));

        return layer;
    }

    function DrawOverlay(color, position, data)
    {
        const size = 32;
        const d = 16;
        
        var inverted = InvertColor(color);

        var layer = new Konva.Group();

        layer.add(new Konva.Line({
            points: [position, 0, position + data.width * 1, data.height * 1],
            stroke: inverted.toHexString(),
            strokeWidth: 8
        }));

        layer.add(new Konva.Line({
            points: [position, data.height * 1, position + data.width * 1, 0],
            stroke: inverted.toHexString(),
            strokeWidth: 8
        }));

        var radius = Math.min(data.width, data.height) / 2;

        layer.add(new Konva.Circle({
            x: position + data.width / 2,
            y: data.height / 2,
            radius: radius,
            stroke: inverted.toHexString(),
            strokeWidth: 8
        }));

        var text = new Konva.Text({
            text: data.width + "x" + data.height + "\n" + data.text,
            fontFamily: 'Calibri',
            fontSize: 30,
            fill: inverted.toHexString(),
            x: 0,
            y: 0,
            align: 'center'
        });

        layer.add(new Konva.Rect({
            width: text.width() * 1.25,
            height: text.height() * 1.25,
            x: position + data.width / 2 - (text.width() * 1.25) / 2,
            y: data.height / 2 - (text.height() * 1.25) / 2,
            fill: color.toHexString()
        }));

        //alert( data.height / 2 - text.height() / 2);
        text.x(position + data.width / 2 - text.width() / 2);
        text.y(data.height / 2 - text.height() / 2);

        layer.add(text);


        return layer;
    }

    function DrawGrid(stage, size)
    {
        var layer = new Konva.Group();
        var cx = stage.width() / 2;
        var cy = stage.height() / 2;

        var countx = Math.ceil((cx * 2) / size);
        var county = Math.ceil((cy * 2) / size);

        for (var i = 0; i < county; i++)
        {
            layer.add(new Konva.Line({
                points: [0, cy - size * i, cx * 2, cy - size * i],
                stroke: 'black',
                strokeWidth: 2
            }));
            layer.add(new Konva.Line({
                points: [0, cy + size * i, cx * 2, cy + size * i],
                stroke: 'black',
                strokeWidth: 2
            }));
        }

        for (var i = 0; i < countx; i++)
        {
            layer.add(new Konva.Line({
                points: [cx - size * i, 0, cx - size * i, cy * 2],
                stroke: 'black',
                strokeWidth: 2
            }));
            layer.add(new Konva.Line({
                points: [cx + size * i, 0, cx + size * i, cy * 2],
                stroke: 'black',
                strokeWidth: 2
            }));
        }

        return layer;
    }

    function DrawCheckerboard(stage, size)
    {
        var layer = new Konva.Group();
        var cx = stage.width() / 2;
        var cy = stage.height() / 2;

        var countx = Math.ceil((cx * 2) / size);
        var county = Math.ceil((cy * 2) / size);

        var color1 = tinycolor('gray');
        
        for (var i = 0; i < county; i++)
        for (var j = 0; j < countx; j++)
            if (i % 2 == j % 2)
            {
                //var color = GetPixel(canvas, Math.abs(Math.floor((cx - size * j + size / 2) % stage.width())), Math.abs(Math.floor((cy - size * i + size / 2) % stage.height()))).darken(20);
                if (i != 0)
                    layer.add(new Konva.Rect({
                        x: cx - size * j,
                        y: cy - size * i,
                        width: size,
                        height: size,
                        fill: color1.toHexString(),
                        globalCompositeOperation: 'multiply'
                    }));
                //color = GetPixel(canvas, Math.abs(Math.floor((cx + size * j + size / 2) % stage.width())), Math.abs(Math.floor((cy - size * i + size / 2) % stage.height()))).darken(20);
                if (j != 0)
                    layer.add(new Konva.Rect({
                        x: cx + size * j,
                        y: cy - size * i,
                        width: size,
                        height: size,
                        fill: color1.toHexString(),
                        globalCompositeOperation: 'multiply'
                    }));
                //color = GetPixel(canvas, Math.abs(Math.floor((cx - size * j + size / 2) % stage.width())), Math.abs(Math.floor((cy + size * i + size / 2) % stage.height()))).darken(20);
                if (j != 0)
                    layer.add(new Konva.Rect({
                        x: cx - size * j,
                        y: cy + size * i,
                        width: size,
                        height: size,
                        fill: color1.toHexString(),
                        globalCompositeOperation: 'multiply'
                    }));
                //var color = GetPixel(canvas, Math.abs(Math.floor((cx + size * j + size / 2) % stage.width())), Math.abs(Math.floor((cy + size * i + size / 2) % stage.height()))).darken(20);
                if (i != 0)
                    layer.add(new Konva.Rect({
                        x: cx + size * j,
                        y: cy + size * i,
                        width: size,
                        height: size,
                        fill: color1.toHexString(),
                        globalCompositeOperation: 'multiply'
                    }));
            }

        return layer;
    }

    function DrawNumbers(stage, size)
    {
        var layer = new Konva.Group();
        var cx = stage.width() / 2;
        var cy = stage.height() / 2;

        var countx = Math.ceil((cx * 2) / size);
        var county = Math.ceil((cy * 2) / size);

        var color = tinycolor('white');
        var stroke = tinycolor('black');

        for (var i = 0; i <= county; i++)
            for (var j = 0; j <= countx; j++)
            {
                var idx = ((i + 1) * (j + 1)) % 512;
                //var color = InvertColor(GetPixel(canvas, Math.abs(Math.floor((cx - size * j + size / 2) % stage.width())), Math.abs(Math.floor((cy - size * i + size / 2) % stage.height()))));
                if (i != 0)
                {
                    var text = new Konva.Text({
                        x: cx - size * j,
                        y: cy - size * i,
                        width: size,
                        //height: size,
                        align: 'center',
                        text: idx,
                        fontFamily: 'Calibri',
                        fontWeight: 'bold',
                        fill: color.toHexString(),
                        fontSize: size / 2,
                        globalCompositeOperation: 'difference',
                    });
                    text.setOffset({
                        y: text.height() / 2 - size / 2,
                    });
                    layer.add(text);
                }
                //color = InvertColor(GetPixel(canvas, Math.abs(Math.floor((cx + size * j + size / 2) % stage.width())), Math.abs(Math.floor((cy - size * i + size / 2) % stage.height()))));
                if (j != 0)
                {
                    text = new Konva.Text({
                        x: cx + size * j,
                        y: cy - size * i,
                        width: size,
                        //height: size,
                        align: 'center',
                        text: idx,
                        fontFamily: 'Calibri',
                        fontWeight: 'bold',
                        fill: color.toHexString(),
                        fontSize: size / 2,
                        globalCompositeOperation: 'difference',
                    });
                    text.setOffset({
                        y: text.height() / 2 - size / 2,
                    });
                    layer.add(text);
                }
                //color = InvertColor(GetPixel(canvas, Math.abs(Math.floor((cx - size * j + size / 2) % stage.width())), Math.abs(Math.floor((cy + size * i + size / 2) % stage.height()))));
                if (j != 0)
                {
                    text = new Konva.Text({
                        x: cx - size * j,
                        y: cy + size * i,
                        width: size,
                        //height: size,
                        align: 'center',
                        text: idx,
                        fontFamily: 'Calibri',
                        fontWeight: 'bold',
                        fill: color.toHexString(),
                        fontSize: size / 2,
                        globalCompositeOperation: 'difference',
                    });
                    text.setOffset({
                        y: text.height() / 2 - size / 2,
                    });
                    layer.add(text);
                }
                //var color = InvertColor(GetPixel(canvas, Math.abs(Math.floor((cx + size * j + size / 2) % stage.width())), Math.abs(Math.floor((cy + size * i + size / 2) % stage.height()))));
                if (i != 0)
                {
                    text = new Konva.Text({
                        x: cx + size * j,
                        y: cy + size * i,
                        width: size,
                        //height: size,
                        align: 'center',
                        text: idx,
                        fontFamily: 'Calibri',
                        fontWeight: 'bold',
                        fill: color.toHexString(),
                        fontSize: size / 2,
                        globalCompositeOperation: 'difference',
                    });
                    text.setOffset({
                        y: text.height() / 2 - size / 2,
                    });
                    layer.add(text);
                }
                }
        return layer;
    }

    $("#addRect").on('click', function (e)
    {
        $("#preRect").before('<div style="display: collapsed" class="form-group panel panel-default" id="screen' + rectCount + '">\
                        <div class="panel-heading">Экран №' + (rectCount + 1) + '</div>\
                        <div class="panel-body">\
                            <label for="text">Текст</label>\
                            <input class="form-control" name="rect[' + rectCount + '][text]" id="text" value="Экран"/>\
                            <label for="width">Ширина</label>\
                            <input class="form-control" name="rect[' + rectCount + '][width]" type="number" id="width" value="1024"/>\
                            <label for="height">Высота</label>\
                            <input class="form-control" name="rect[' + rectCount + '][height]" type="number" id="height" value="768"/>\
                            <label for="color">Цвет</label>\
                            <input class="form-control" name="rect[' + rectCount + '][color]" type="color" id="color" value="' + tinycolor(colors[rectCount % colors.length]).toHexString() + '" style="height: 50px"/>\
                            <br/>\
                            <button id="removeScreen' + rectCount + '" data-rect="' + rectCount + '" class="form-control btn btn-danger btn-block">УДАЛИТЬ ЭКРАН</button>\
                        </div>\
                    </div>');
        $("#removeScreen" + rectCount).on('click', function (e)
        {

            anime({
            targets: "#screen" + $(this).data("rect"),
            height: 0,
            opacity: 0,
            duration: 500,
            complete: function () {
                    $("#screen" + $(this).data("rect")).remove();
                }.bind(this),
            easing: 'linear'
            });
            
            e.preventDefault();
        });
        var height = $("#screen" + rectCount).height();
        $("#screen" + rectCount).css({height: 0, display: 'block'});
        anime({
            targets: "#screen" + rectCount,
            height: [0, height],
            opacity: [0, 1],
            duration: 500,
            easing: 'linear'
        });
        rectCount++;
        e.preventDefault();
        
    });
    $("#genform").on('submit', function (e)
    {
        e.preventDefault();
        var obj = $("form").serializeObject().rect.filter(function(n){return n !== undefined});
        var sumWidth = $.map(obj, function(el, idx) { return el.width}).reduce(function (sum, next) { return sum + next * 1 }, 0)
        var maxHeight = Math.max.apply(null, $.map(obj, function(el, idx) { return el.height * 1 }));

        window.location =
        GeneratePixelMap(sumWidth, maxHeight, obj).toDataURL({mimeType: "image/png"});
        
    });
</script>
</html>